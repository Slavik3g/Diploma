\section{ПРОГРАММА И МЕТОДИКА ИСПЫТАНИЙ}
\label{sec:testing}

В данном разделе рассмотрено тестирование разработанной системы.
Его необходимо проводить перед выпуском продукта или системы
с целью выявления ошибок и их устранения, для проверки соответствия продукта
заявленным требованиям, оценки качества работы разработчиков,
получения информации о сложности системы и ее характеристиках. Тестирование
обеспечивает безопасность кода при командной работе, помогает в создании наилучшей
архитектуры, улучшает качество кода, упрощает исправление ошибок и экономит денежные
средства организации.

\subsection{Классификации методов тестирования}

Тестирование программного обеспечения~\cite{testing_epam} -- это проверка 
соответствия между реальным и ожидаемым поведением программы, 
осуществляемая при конечном наборе тестов, выбранным определенным 
образом.

Существует множество подходов к тестированию программного 
обеспечения, в зависимости от целей, преследуемых при тестировании.

Все виды тестирования программного обеспечения, в зависимости от 
преследуемых целей, можно условно разделить на следующие группы:

\begin{itemize}
    \item функциональные;
    \item нефункциональные;
    \item связанные с изменениями.
\end{itemize}

\subsubsection{Классификации функционального тестирования}

По классификации доступа к коду программного продукта выделяют три 
типа тестирования:

\begin{itemize}
    \item тестирование белого ящика;
    \item тестирование черного ящика;
    \item тестирование серого ящика.
\end{itemize}

Тестирование белого ящика~-- это метод тестирования, который 
подразумевает доступность кодовой базы и архитектурных решений для 
разработчика тестов во время тестирования. Разработчик сам выбирает 
входные значения, основываясь на знании кода, который будет обрабатывать 
эти значения. Данный тип тестирования может производиться на ранних 
этапах, так как нет необходимости ждать пользовательских интерфейсов. 
Тестирование белого ящика является более тщательным и может покрыть 
большее количество путей выполнения программы. Степень сложности 
тестирования зависит от сложности приложения и количества функций, 
которое оно выполняет.

Тестирование черного ящика~-- это метод тестирования, при котором 
работа приложения исследуется без знания кодовой базы, деталей реализации 
и архитектурных решений. Данный метод имитирует поведение пользователя. 
Тестирование методом черного ящика позволяет найти ошибки в 
функциональных спецификациях, если полученный результат отличается от 
заявленного. К сожалению, данный метод далеко не всегда является 
достаточным, так как тестируется ограниченное количество путей выполнения 
программы.

Тестирование серого ящика~-- это метод тестирования, который 
предполагает комбинацию подходов двух методов, перечисленных выше. 
Данный вид тестирования предполагает частичное знание внутренней 
организации тестируемой системы. Тесты разрабатываются на основе знаний 
алгоритмов, архитектуры, внутренних состояний или других 
высокоуровневых описаний поведения программы.

В зависимости от того, используют ли тестировщики дополнительные 
программные средства для тестирования программного обеспечения, 
тестирование делится на:

\begin{itemize}
    \item ручное;
    \item автоматизированное.
\end{itemize}

По уровню тестирования выделяют:

\begin{itemize}
    \item модульное тестирование;
    \item интеграционное тестирование;
    \item системное тестирование;
    \item приемочное тестирование.
\end{itemize}

Модульное тестирование~-- это тестирование каждой атомарной 
функциональности приложения отдельно, в искусственно созданной для этого 
среде. Данная среда для модуля создается путем создания «заглушек». В 
данном контексте заглушкой является часть программы, которая выполняет 
обмен данными с тестируемым компонентом, имитируя при этом логику 
работы программы. Основная цель модульного тестирования~--
удостовериться в соответствии требованиям каждого отдельного модуля 
системы перед тем, как будет произведена его интеграция в состав системы.

Интеграционное тестирование~-- это тестирование, предназначенное для 
проверки связи между модулями (компонентами), а также взаимодействие с 
различными частями системы. Выделяют несколько подходов модульного 
тестирования: 
\begin{itemize}
    \item «Снизу вверх»;
    \item «Сверху вниз»;
    \item «Большой взрыв».
\end{itemize}

При тестировании «Снизу вверх» изначально тестируются низкоуровневые 
уровни, после чего собирается следующий уровень модулей для проведения 
интеграционного тестирования. В подходе «Сверху вниз» сначала 
тестируются более высокоуровневые модули, а затем уже низкоуровневые. 
При «Большом взрыве» вся система собирается воедино и тестируется.

Системное тестирование~-- этап тестирования, который исследует 
поведение на полной, интегрированной системе, с целью соответствия 
системы исходным требованиям, как функциональным, так и 
нефункциональным. Системное тестирование выполняется методом «Черного 
ящика», так как проверяемое множество является «внешними» сущностями, 
которые не требуют взаимодействия с внутренним устройством программы. 
Также выполнять его рекомендуется в окружении, максимально 
приближенном к окружению конечного пользователя

Приемочное тестирование~-- это последний этап тестирования, который 
проводится перед передачей программного обеспечения клиенту. Данный этап 
проводится, чтобы гарантировать, что разработанное программное 
обеспечение отвечает требованием заказчика. Существует два типа 
приемочного тестирования~-- то, которое выполняется членами команды 
разработчиков, также известное как «альфа тестирование», и то, которое 
проводится заказчиком. В случае, если тестирование проводится конечными 
пользователями, оно известно, как «бета тестирование»~\cite{testing_epam}.

\subsubsection{Классификации нефункционального тестирования}

В отличие от функционального тестирования, целью которого является 
проверка соответствия реальных функций продукта с функциональными 
требованиями, целью нефункционального тестирования является проверка 
соответствия свойств приложения с его нефункциональными требованиями.
Соответственно: нефункциональное тестирование~-- тестирование 
свойств, которые не относятся к функциональности системы. Данные свойства 
определяются нефункциональными требованиями, которые характеризуют 
продукт с таких сторон, как:

\begin{itemize}
    \item надежность;
    \item стрессоустойчивость;
    \item удобство;
    \item качество;
    \item безопасность.
\end{itemize}

Задачей тестирования надежности (стабильности) является проверка 
работоспособности приложения при длительном (многочасовом) 
тестировании со средним уровнем нагрузки. Время выполнения операций 
может играть в данном виде тестирования второстепенную роль. При этом на 
первое место выходит отсутствие утечек памяти, перезагрузок серверов под 
нагрузкой и другие аспекты, влияющие именно на стабильность работы.

Стресс-тестирование является методом, при котором программное 
обеспечение подвергается воздействию условий, которые выходят за рамки 
нормальных условий работы программного обеспечения. После достижения 
критической точки, полученные результаты записываются. Этот тест 
определяет устойчивость всей системы.

Безопасность приложения является одной из главных задач 
разработчика. Тестирование безопасности проверяет программное 
обеспечение на обеспечение конфиденциальности, целостности, 
аутентификации, доступности и безотказности. Индивидуальные испытания 
проводятся в целях предотвращения несанкционированного доступа в 
программный код.

Тестирование удобства проверяет аспект удобства и практичности 
программного обеспечения для пользователей. Легкость, с которой 
пользователь может получить доступ к устройству, формирует основную 
точку тестирования. Usability-тестирование охватывает пять аспектов 
тестирования~\cite{testing_epam}:

\begin{itemize}
    \item обучаемость;
    \item эффективность;
    \item удовлетворенность;
    \item запоминаемость;
    \item ошибки.
\end{itemize}

\subsection{Статические анализаторы кода}

Отдельное место в этапе разработки и тестирования занимают 
статические анализаторы кода.

Статический анализ кода~-- это процесс выявления ошибок и недочетов 
в исходном коде программ. Данный процесс помогает в решении следующих 
задач:

\begin{itemize}
    \item выявление ошибок;
    \item рекомендации по оформлению кода;
    \item подсчет метрик.
\end{itemize}

Стоит упомянуть, что, говоря об ошибках, обнаруживаемых 
анализаторами кода, как правило, имеют в виду два типа ошибок. К первому 
относятся ошибки стиля (неправильные отступы, длинные строки), ко второму 
ошибки в логике программы и ошибки синтаксиса языка программирования 
(опечатки при написании названий стандартных функций, неиспользуемые 
импорты, дублирование кода). Существуют и другие виды ошибок, например~-- оставленные в коде пароли или высокая цикломатическая сложность~\cite{cyclomatic-complexity}.

Для языка Python разработан стандарт PEP8, регламентирующих 
основные аспекты написания кода. Стандарт был представлен разработчиком 
языка Python~-- Гвидо Ван Россумом~--. Ключевая идея данного стандарта, 
сказанная Гвидо: «код читается намного больше раз, чем пишется»~-- именно 
на это направлен стандарт. По данному стандарту было разработано 
множество различных анализаторов кода, наиболее популярные из них:

\begin{itemize}
    \item black;
    \item pylint;
    \item pyflakes;
    \item flake8.
\end{itemize}

В качестве статического анализатора для данного проекта был выбран 
black. Установка black в Google Colab происходит следующим образом:

\begin{enumerate_num}
    \item Импортировать модуль \lstinline{drive} из библиотеки \lstinline{google.colab}: \lstinline{from google.colab import drive}.
    \item Примонтировать Google диск к Colab-ноутбуку: \lstinline{drive.mount('/content/drive')}.
    \item Установить \lstinline{black} для \lstinline{jupyter}: \lstinline{!pip install black[jupyter]}.
    \item Перезагрузить ядро.
\end{enumerate_num}

Поле этого необходимо загрузить на диск файл \lstinline{.ipynb} на диск и вызвать команду:

\begin{lstlisting}[basicstyle=\ttfamily\small]
    !black /content/drive/MyDrive/NOTEBOOK.ipynb
\end{lstlisting}

Данная команда вызывает инструмент форматирования кода \lstinline{black} для файла \lstinline{NOTEBOOK.ipynb}, который находится в директории \lstinline{/content/drive/MyDrive/} в Google Диске. Этот инструмент может принимать разные флаги для настройки процесса форматирования. Вот некоторые из них:

\begin{enumerate_num}
    \item \lstinline{--line-length N}: этот флаг позволяет установить максимальную длину строки в символах. Например, \lstinline{--line-length N} ограничит строки до N символов в длину.
    \item \lstinline{--skip-string-normalization}: этот флаг отключает нормализацию строковых литералов в коде.
    \item \lstinline{--exclude pattern}: позволяет исключить файлы или директории из процесса форматирования. Вы можете указать шаблон для файлов или директорий, которые следует пропустить.
    \item \lstinline{--check}: Флаг, который позволяет только проверить файлы на соответствие стандарту форматирования без их изменения.
    \item \lstinline{--quiet} или \lstinline{-q}: сокращенная форма для подавления вывода, кроме ошибок.
    \item \lstinline{--verbose} или \lstinline{-v}: выводит дополнительные сообщения о процессе форматирования.
    \item \lstinline{--config FILE}: позволяет указать файл конфигурации, содержащий настройки форматирования.
    \item \lstinline{--target-version N}: задает целевую версию Python для форматирования.
    \item \lstinline{--fast}: выполняет форматирование быстрее.
\end{enumerate_num}

Более подробную информацию о флагах и других параметрах, запустив \lstinline{!black --help} в блокноте.

\subsection{Ручное тестирование}

Ручное тестирование~-- это процесс проверки программного 
обеспечения, выполняемый вручную. Программное обеспечение проверяется 
тестировщиком, который берет на себя роль конечного пользователя. 
Происходит моделирование ситуации в соответствии с тестовыми сценариями 
и фиксирование результата. Основная задача ручного тестирования~-- выявить 
любое поведение, которое отклоняется от ожидаемого результата~\cite{testing_epam}.

Для разрабатываемого приложения был реализован именно данный 
подход тестирования. 

Далее по тексту подробно описаны тестируемые сценарии и ожидаемые и фактические результаты. По полученным результатам можно сделать вывод о том, что данное приложение работает корректно.

\subsubsection{Тест загрузки изображения}

Сценарий. запуск команды \lstinline{img = Image.open(img_path)} для открытия изображения. 

Ожидаемый результат. Функция успешно открывает изображение, и в переменной \lstinline{img} содержится валидный объект изображения. Никаких исключений или ошибок не возникает.

Фактический результат. Функция успешно открывает изображение, и в переменной \lstinline{img} содержится валидный объект изображения. Никаких исключений или ошибок не возникает.

\subsubsection{Тест генерации изображения}

Сценарий. Предусловия~-- выбраны необходимые параметры в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и нажата кнопка <<Продолжить>>. Выделить необходимую область на изображении и написан промт, нажать на кнопку <<Поехали>>.

Ожидаемый результат. Выводится маска и строка прогресса о степени готовности изображения.

Фактический результат. Выводится маска и строка прогресса о степени готовности изображения.

\subsubsection{Тест изменения данных в форме для изменения изображений}

Сценарий. Предусловия~-- открыта форма для изменения изображение. Изменить значения в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>>. 

Ожидаемый результат. Поля <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> успешно изменяются.

Фактический результат. Поля <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> успешно изменяются.

\subsubsection{Тест открытия формы для изменения изображений}

Сценарий. Предусловия~-- загружено изображение в \lstinline{img} и создан объект класса \lstinline{DiffiusionPainter} с входными данными изображения. Запуск команды \lstinline{img = Image.open(diffusion_painter.predict()} для открытия формы для внесения изменений на картинку. 

Ожидаемый результат. Форма успешно открывается и видно поля: <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и кнопки <<Продолжить>>, <<Остановить>>, а также видно само изображение.

Фактический результат. Форма успешно открывается и видно поля: <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и кнопки <<Продолжить>>, <<Остановить>>, а также видно само изображение.

\subsubsection{Тест выделения области для изменения на изображении}

Сценарий. Предусловия~-- выбраны необходимые параметры в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и нажата кнопка <<Продолжить>>. Курсром мыши выделить области на изображении.

Ожидаемый результат. На изображении видно выделенные области.

Фактический результат. На изображении видно выделенные области.

\subsubsection{Тест изменения размера кисти}

Сценарий. Предусловия~-- выбраны необходимые параметры в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и нажата кнопка <<Продолжить>>. Изменить ползунком размер кисти и проверить что на изображении меняется размер выделяемой области.

Ожидаемый результат. Размер выделяемой области меняется.

Фактический результат. Размер выделяемой области меняется.

\subsubsection{Тест старта генерации изображения}

Сценарий. Предусловия~-- выбраны необходимые параметры в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и нажата кнопка <<Продолжить>>. Выделить необходимую область на изображении и написан промт, нажать на кнопку <<Поехали>>.

Ожидаемый результат. Выводится маска и строка прогресса о степени готовности изображения.

Фактический результат. Выводится маска и строка прогресса о степени готовности изображения.

\subsubsection{Тест записи промта для изображения}

Сценарий. Предусловия~-- выбраны необходимые параметры в полях <<Количество изображений>>, <<Масштаб>>, <<Шаги>>, <<Показать>> и нажата кнопка <<Продолжить>>. Записать промт для изменения в поле для ввода текста.

Ожидаемый результат. Текст успешно записывается.

Фактический результат. Текст успешно записывается.

\subsubsection{Тест сохранения изображения после генерации}

Сценарий. Предусловия~-- изображения изменены и пользователь выбрал необходимое изображение для сохранения. Нажать на кнопку остановить

Ожидаемый результат. Новое изображение сохраняется в файл с именем \lstinline{<image_name>_new}.

Фактический результат. Новое изображение сохраняется в файл с именем \lstinline{<image_name>_new}.

\subsubsection{Тест вывода сохраненного изображения}

Сценарий. Предусловия~-- изображения изменены и пользователь выбрал необходимое изображение для сохранения. Нажать на кнопку остановить. Запустить вывод изображение.

Ожидаемый результат. Новое изображение открывается из файла с именем \lstinline{<image_name>_new} и выводится вместо со старым.

Фактический результат. Новое изображение сохраняется в файл с именем \lstinline{<image_name>_new} и выводится вместо со старым.
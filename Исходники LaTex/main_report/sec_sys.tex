\section{СИСТЕМНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:sys}

После изучения теоретических аспектов разрабатываемого приложения
и формирования списка требований необходимых для разработки 
приложения, необходимо разбить приложение на функциональные блоки
(модули). Это необходимо для обеспечения гибкой архитектуры. Такой 
подход позволяет изменять или заменять модули без изменения всей системы 
в целом.

Выделение модулей также упрощает совместную разработку программного продукта несколькими программистами: каждый имеет возможность писать и тестировать отдельный модуль независимо от других. Также данный тип проектирования предотвращает возникновение ошибок на начальных этапах создания проекта, делает программный продукт более надежным.

\subsection{Общая структура приложения}

После анализа требуемых для реализации программного продукта функций было решено разбить программу на следующие модули:
\begin{itemize}
    \item блок первичной обработки;
    \item блок обработки текста;
    \item блок автоматической сегментации;
    \item блок сегментации по точкам;
    \item блок обработки маски;
    \item блок обработки данных для диффузионной модели;
    \item блок работы диффузионной модели;
    \item блок графического интерфейса.
\end{itemize}

Взаимосвязь между блоками отражена на структурной схеме \structScheme.

\subsection{Блок первичной обработки}

В блоке первичной обработки процесс сначала происходит загрузка изображения в систему из различных источников, таких как файлы, камеры или интернет, обычно в форматах JPEG или PNG. Затем, изображение подвергается серии предварительных операций обработки: это может включать изменение размера изображения, его обрезку, поворот и коррекцию яркости или контраста. Также производится нормализация значений пикселей, что важно для стандартизации данных и повышения качества визуальных данных, подготавливая их к более глубокому анализу.

На следующем этапе, изображение трансформируется в числовой формат, где каждый пиксель представлен через значения яркости или цвета, используя, например, формат RGB для цветных изображений. Это числовое представление критически важно для анализа нейросетью, поскольку она обрабатывает исключительно числовые данные. В этом процессе также проводится дополнительная нормализация пиксельных значений, что способствует более эффективному обучению нейронной сети и улучшает её общую стабильность и точность.

Завершающий этап~-- это подача изображения на вход нейронной сети, где оно проходит через слои обработки, включая сверточные и полносвязные. В этих слоях проводятся различные математические операции и применяются активационные функции, что позволяет сети анализировать изображение в комплексе и принимать основанные на нём решения. Таким образом, сеть анализирует изображение и принимает на его основе решения, завершая процесс обработки изображений.

\subsection{Блок обработки текста}

В данноый блок передаётся текстовое описание тех изменений, которые пользователь хочет видеть на окончательном изображении. Это описание может указывать на изменение цвета, добавление деталей или любую другую спецификацию, которая изменит исходное изображение в желаемом направлении.

В данном блоке применяется текстовый кодировщик, основанный на архитектуре Transformer, который является специализированной языковой моделью. Эта модель технически описывается как текстовый кодировщик модели CLIP. Модель CLIP (Contrastive Language-Image Pre-training) разработана для одновременного понимания текста и визуальных данных, и в данном случае, часть, отвечающая за обработку текста, использует механизмы Transformer для анализа и кодирования текстовых данных. Это позволяет эффективно извлекать семантическое содержание из текста, что является ключевым для дальнейшей интеграции и взаимодействия с визуальными компонентами в модели. Она получает на входе текст и выдаёт на выходе список чисел, описывающий каждое слово/токен в тексте. Которые в последствии передаёт эту информацию генератору изображений.

\subsection{Блок автоматической сегментации}

В данном блоке, после того как входное изображение проходит начальные этапы обработки, оно подается на вход специализированной нейронной сети, обученной выполнению задачи сегментации. Этот процесс включает анализ изображения с целью выделения и классификации различных объектов, присутствующих на нем. Нейросеть определяет и выделяет каждый объект, создавая отдельные маски для них. Маска для каждого объекта~-- это, по сути, карта, где каждый пиксель отмечен в зависимости от того, принадлежит ли он данному объекту, что позволяет точно определить границы объекта на изображении.

Как результат, будет получен набор масок, каждая из которых соответствует определенному объекту на фотографии, с четко обозначенными границами. Эти маски могут быть использованы в последующих этапах для различных целей, например, для того, чтобы пользователь мог внести специфические изменения в выбранные объекты на изображении.

Для задачи сегментации будет применена модель U-Net. Данная архитектура сверточной нейронной сети (CNN), первоначально разработанная для медицинской сегментации изображений, которая впоследствии нашла применение в различных других задачах обработки изображений. Основная особенность этой модели заключается в её U-образной структуре, которая делит архитектуру на две основные части: сжимающий путь или энкодер и расширяющий путь или декодер. Энкодер состоит из серии сверточных и пуллинговых слоев, которые уменьшают размеры изображения, позволяя извлекать и уплотнять признаки из изображения для последующей классификации различных регионов. Декодер, напротив, включает операции апсемплинга, которые постепенно восстанавливают размер изображения до исходного, при этом уровни энкодера соединяются с соответствующими уровнями декодера для передачи контекстуальной информации, что помогает в точной локализации границ объектов.

Изначально разработанная для медицинских применений, где требуется высокая точность в идентификации тканей и анатомических структур, U-Net быстро стала популярна и в других областях, таких как анализ аэрофотоснимков, обработка сателлитных изображений и даже в сферах, связанных с искусством и видеоиграми. Благодаря своей универсальности, эффективности и относительной простоте реализации по сравнению с более сложными моделями, U-Net продолжает оставаться одной из ведущих архитектур для задач сегментации изображений.

\subsection{Блок сегментации по точкам}

Данный блок является инструментом, который дополняет стандартный механизм автоматической сегментации. Этот подход предоставляет пользователю интерфейс для прямого взаимодействия с изображением через графический пользовательский интерфейс, позволяя выборочно указывать области для сегментации и области для исключения из процесса сегментации путем непосредственного указаниям пользователем данных точек.

Технически, блок обрабатывает входные сигналы, полученные от пользователя, и преобразует их в координаты на изображении. Эти координаты используются затем для динамической модификации весов сегментационной модели или для непосредственного создания пользовательских масок сегментации. В ответ, алгоритм сегментации адаптируется к указанным предпочтениям пользователя, генерируя маски, которые точно соответствуют заданным пользователем областям, включая детальное выделение или исключение определенных элементов сцены.

\subsection{Блок обработки маски}

В данном блоке реализована функция, которая предназначен для детальной работы с большими или маленькими масками объектов, полученными в результате процесса сегментации. После того как первичная маска объекта создана, блок позволяет выполнить её дальнейшее разделение на более мелкие маски или объединение мелких в более крупную маску, что особенно актуально для сложных объектов, состоящих из множества деталей.

Результатом работы блок является набор детализированных масок, каждая из которых точно отражает структуру составной части исходного объекта. Эти маски могут быть использованы для более точной визуализации, анализа или последующей обработки объектов. 

\subsection{Блок обработки данных для диффузионной модели}

В рамках данного блока происходит передача маски объекта, исходного изображения, а также текстового описания изменений, которые необходимо внести, в диффузионную модель. Этот процесс начинается с получения маски объекта, которая выделяет специфические элементы или области в исходном изображении. Кроме того, подается само изображение, на котором основана маска. После которого все данные передаются в блок работы диффузионной модели.

\subsection{Блок работы диффузионной модели для генерации изображение}

Блок работы диффузионной модели занимается генерацией изображений и визуальных элементов из шума посредством постепенного обучения и уточнения. Диффузионные модели~-- это тип генеративных моделей машинного обучения, которые функционируют, перемещаясь от случайного шума к структурированному выходу (изображению), применяя серию обратных шагов, каждый из которых уменьшает количество шума и увеличивает детализацию и качество изображения.

В основе блока работы диффузионной модели лежит итерационный процесс, в котором модель сначала создаёт зашумлённое изображение, а затем постепенно удаляет шум, в то время как структура изображения начинает формироваться более чётко. Это достигается через применение специализированных алгоритмов и сетей, которые были обучены угадывать, как убрать шум на каждом шаге, приближаясь к исходному или желаемому изображению.

В данном модуле будет использоваться модель генерации изображений на основе диффузионных моделей Stable Diffusion, разработанная для создания высококачественных визуальных содержаний. Это мощный инструмент, который использует машинное обучение для превращения текстовых описаний в детализированные изображения. Структура Stable Diffusion включает в себя нейронные сети, которые обучены работать с большим набором данных, включающим миллионы разнообразных изображений, что позволяет модели генерировать визуальные изображения, отвечающие широкому спектру запросов пользователя.

Stable Diffusion отличается высокой степенью кастомизации и способностью к масштабированию, что делает её подходящей для широкого спектра применений, от художественного творчества до коммерческого дизайна и медийного производства. Это инновационное решение, которое значительно расширяет возможности визуального сторителлинга и цифрового искусства.

\subsection{Блок графического интерфейса}

Блок графического интерфейса, который интегрирован с модулем, представляет собой важный компонент пользовательского взаимодействия, позволяя пользователям легко управлять функционалом модуля через удобный, интуитивно понятный интерфейс. Этот блок включает в себя различные графические элементы управления, такие как кнопки, ползунки, текстовые поля и возможно визуальные индикаторы, которые позволяют пользователю вводить данные, инициировать процессы и получать обратную связь от системы. Для достижения максимальной гибкости будет использоваться Java Script.

На начальном этапе, при создании графического интерфейса, определяется компоновка модуля учитывая лучшие практики UX/UI дизайна, чтобы обеспечить удобство и эффективность взаимодействия с модулем.

Интерактивность интерфейса достигается за счет использования JavaScript для обработки событий, таких как клики мыши, ввод данных и другие пользовательские действия. Кроме того, JavaScript работает с CSS для стилизации элементов интерфейса, позволяя создать визуально привлекательный и функциональный дизайн. Это включает в себя анимации, переходы и другие визуальные эффекты, которые улучшают взаимодействие пользователя с интерфейсом и делают использование модуля более приятным и эффективным.

% Выделение модулей также упрощает совместную разработку программного продукта несколькими программистами: каждый имеет возможность писать и тестировать отдельный модуль независимо от других. Также данный тип проектирования предотвращает возникновение ошибок на начальных этапах создания проекта, делает программный продукт более надежным.

% После анализа требуемых для реализации программного продукта функций было решено разбить программу на следующие модули:

% \begin{itemize}
%     \item модуль \moduleCfg;
%     \item модуль \moduleXml;
%     \item модуль \moduleSettingsApply;
%     \item модуль \moduleRecvPackets;
%     \item модуль \moduleThreads;
%     \item модуль \moduleProcessPackets;
%     \item модуль \moduleDataStoring;
%     \item модуль \moduleOsal;
%     \item модуль \moduleLog.
% \end{itemize}

% Взаимосвязь между основными компонентами проекта отражена на структурной схеме
% \structScheme.

% \subsection{Модуль \moduleCfg}

% Модуль \moduleCfg\ является самым важным модулем, который обеспечивает работу устройства. Одной из задач модуля является быстрая загрузка или восстановление работоспособности устройства после подачи питания. Он считывает данные из \cid-файла, который находится в файловой системе целевого устройства и содержит все базовые настройки оборудования РЗА. Модуль записывает считанные данные в память, откуда в свою очередь все модули системы берут стартовые значения при начальном запуске, экстренной перезагрузке или обновлении конфигурации.

% \nomenclaturex{ICD}{IED Capability Description}{описание возможностей IED}
% \nomenclaturex{XML}{Extensible Markup Language}{расширяемый язык разметки}

% Считывание данных из \cid-файла происходит посредством модуля \moduleXml. При невозможности считать, обработать \cid-файл или его некоторые параметры, модуль \moduleCfg\ не дает системе прекратить свою работу. Для этого используются последние успешно загруженные настройки, которые сохраняются в энергонезависимой памяти. В случае первого запуска прибора или повреждении основного и резервного источников настроек, существует начальная конфигурация, поставляемая в качестве компонента программного обеспечения.

% Описанный способ резервирования данных обеспечивает надежность системы.

% \subsection{Модуль \moduleXml}

% Данный модуль является вспомогательным для модуля \moduleCfg. Он считывает данных из \cid-файла и производит его обработку. \cid-файл использует \xml-разметку для \moduleDataStoring\ и имеет жесткую структуру.

% \nomenclaturex{XSD}{\xml\ Schema Definition}{определение схемы \xml}

% При считывании модуль \moduleXml\ проверяет соответствие данных, типов данных и внутренних структур с \xsd-шаблоном. Схемы проверки корректности \cid-файла являются общедоступными и разрабатываются организацией \iec. Использование \xsd-схем упрощает разработку и исключает необходимость проверки корректности данных разработчиками.
% В случае обнаружения несоответствия с \xsd-схемой \cid-файл считается некорректным и его настройки не применяются.

% Данный модуль используется только при добавлении новой схемы, поэтому не предъявляются требования, касаемые скорости работы и производительности.

% \subsection{Модуль \moduleSettingsApply}

% Основной задачей модуля \moduleSettingsApply\ является считывание данных из общей памяти, в которую модуль \moduleCfg\ с помощью модуля \moduleXml\ поместил их. Данный модуль записывает в остальные модули устройства необходимые данные для их дальнейшей корректной работы. При возникновении ошибки записи он повторяет свою попытку.

% Проверка корректности записываемых данных также является функцией текущего модуля. При перезагрузке устройства, экстренном завершении или перезаписи конфигурации модуль \moduleSettingsApply\ должен регулировать процесс обновления настроек в каждом модуле, контролировать и предотвращать возникновение коллизий данных.

% Одной из задач модуля является минимизация времени, в течение которого устройство не сможет принимать или обрабатывать входные данные. Исходя из этого к модулю \moduleSettingsApply\ предъявляются жесткие требования ко времени работы.

% Данный модуль намеренно разделен с модулем \moduleCfg\ по следующим причинам:
% \begin{itemize}
%     \item разделение процесса \moduleSettingsApply\ на этапы и предъявление разных, независимых друг от друга требований к этим этапам;
%     \item возможность распараллеливания разработки процесса \moduleSettingsApply;
%     \item упрощение тестирования каждого модуля по отдельности;
%     \item возможность разнесения модулей на разные исполняющие устройства и работу этих компонентов параллельно и независимо друг от друга. Особенно это актуально для систем жесткого и мягкого реального времени.
% \end{itemize}

% \subsection{Модуль \moduleRecvPackets}

% Основной задачей модуля \moduleRecvPackets\ является получение Ethernet-пакетов с помощью модуля \moduleOsal. Рассматриваемый модуль отбрасывает пакеты, которые не соответствуют ожидаемому EtherType. Модуль \moduleRecvPackets\ обеспечивает фильтрацию по MAC-адресам, номерам VLAN, а также обеспечивает дедупликацию данных для протоколов HSR и PRP.

% Поскольку модуль является первым модулем в системе, который занимается анализом принимаемых пакетов, его задачей является предотвращение обработки входных данных от тех источников, которые специально пытаются затормозить или прекратить работу устройства с помощью DoS-атак.

% \nomenclaturex{DoS}{Denial of Service}{отказ в обслуживании}

% В большинстве случаев GOOSE-пакеты передаются как мультикаст и широковещательные рассылки, что может привести к лавинному эффекту (широковещательному шторму). Во многих источниках возможность минимизации воздействия данного эффекта на сетевое оборудование называется предотвращением шторма и позволяет работать оборудованию в неблагоприятных сетевых условиях.

% Если принятый пакет удовлетворяет текущей конфигурации системы, то модуль \moduleRecvPackets\ передает его для дальнейшего разбора модулю \moduleProcessPackets.

% \subsection{Модуль \moduleThreads}

% Система, элементом которой является данный дипломный проект, спроектирована таким образом, что возможна работа как на операционной системе Linux, так и на встраиваемых решениях с использованием систем жесткого и мягкого реального времени. Рассматриваемый модуль предназначен для динамического распределения обработки входящих пакетов с целью увеличения производительности и пропускной способности всей системы.

% Особенностью реализации модуля является отслеживание поступающих на обработку потоков данных и обеспечения атомарности данных как в контексте одного потока, так и в контексте всей системы. Это может быть достигнуто с помощью использования примитивов синхронизации либо путем распределения нагрузки таким образом, чтобы в каждый момент времени любые два пакета, которые находятся в состоянии обработки, относились к различным потокам данных.

% В случае использования систем реального времени возникает дополнительная сложность с переносом задач с одного вычислительного ядра на другое. Это особенно актуально для гетерогенных систем: систем на кристалле, которые содержат ядра различных архитектур и микроархитектур, поскольку нужно иметь версии приложения, предназначенные для каждой архитектуры.

% \subsection{Модуль \moduleProcessPackets}

% Модуль \moduleProcessPackets\ является вычислительной единицей, которой манипулирует модуль \moduleThreads. Каждый экземпляр данного модуля обрабатывает пакет данных, который был принят модулем \moduleRecvPackets.

% Основными задачами этого модуля являются проверка корректности входящего пакета, извлечение необходимой информации, формирование структур данных и передача их в модуль \moduleDataStoring. При каждом обнаружении во входящих данных отклонений, превышающих допустимые нормы, модуль генерирует событие, которое может быть обработано другими модулями, и информация о возникновении которого будет записана в модуль \moduleLog.

% Поскольку на данный модуль возлагается задача периодической обработки большого объема данных, он должен минимизировать время взаимодействия с каждым блоком. Это может быть сделано с помощью использования различных структур данных, которые обеспечивают эффективный доступ к последним по мере необходимости:
% \begin{itemize}
%     \item очереди приоритетов;
%     \item кучи;
%     \item хеш-таблицы;
%     \item красно-черные деревья;
%     \item префиксные деревья.
% \end{itemize}

% \subsection{Модуль \moduleDataStoring}

% Модуль \moduleDataStoring\ отвечает за получение информации от модуля \moduleProcessPackets\ и сохранение ее в память. К модулю предъявляются особые требования к производительности, потому что новые пакеты приходят часто, данных много, а система должна с максимальной скоростью справляться с этой задачей. Также очень важно, чтобы данные не перемешивались, не повреждались, следовательно, все операции с памятью рекомендуется защищать примитивами синхронизации.

% Модуль \moduleDataStoring\ не несет ответственность за передачу ему некорректной конфигурации для записи. За это отвечает модуль, который сохраняет данные, а рассматриваемый модуль лишь записывает то, что ему передано. Если часть модулей проявляют свою активность нерегулярно, то модуль \moduleDataStoring\ работает на протяжении всего жизненного цикла системы.

% Также следует обратить внимание на то, что в процессе записи данные проходят проверку на целостность путем расчета контрольной суммы. Если каким-то образом поврежденная информация дошла до данного модуля, что практически исключается, то она не запишется в память.

% Как было упомянуто выше, модуль безостановочно работает в процессе всего жизненного цикла системы, поэтому его реализация предполагается в отдельном потоке, параллельно с работой других модулей и независимо от них.

% \subsection{Модуль \moduleOsal}


% Для того, чтобы наша система имела возможность работать как на операционной системе Linux, так и на встраиваемых решениях с использованием операционных систем реального времени, существует модуль \moduleOsal. Он предоставляет общий интерфейс взаимодействия с различными операционными системами, поэтому каждая платформа имеет свою реализацию данного модуля. Это позволяет производить тестирование системы на базе одной операционной системы, а для остальных платформ требуется минимальное покрытие интеграционными тестами благодаря общей кодовой базе. Рассматриваемый модуль необходимо полноценно тестировать на каждой операционной системе по отдельности.

% Модуль \moduleOsal\ является идеальным решением для параллельной поддержки нескольких операционных систем. Причем реализация одной и той же внешней функции производится на каждой платформе независимо друг от друга и могут разрабатываться одновременно.

% \subsection{Модуль \moduleLog}

% В процессе разработки и поддержки системы необходимо получать информацию о ее состоянии. Для этого используется модуль \moduleLog, с которым взаимодействуют некоторые модули. Он выводит информацию на экран или в среды передачи данных на всех этапах работы системы. Рассматриваемый модуль также сохраняет все сообщения, которые пишет система пользователям или разработчикам, в энергонезависимую память на внутренние или внешние носители. Место сохранения является настраиваемой опцией. Это сделано для того, чтобы существовала возможность в любой момент времени отследить ошибку, если она возникла. Также модуль \moduleLog\ может использоваться для отладки и тестирования, поскольку разработчику необходимо наблюдать реакцию системы при изменении алгоритма работы устройства.

% Одной из задач модуля является форматирование и фильтрация входящих сообщений по уровням приоритета для каждого целевого носителя. Для любого уровня приоритета сообщения определен свой цвет в системе. Это сделано для удобства визуального восприятия и может быть отключено для части исходящих данных. Функция приоритезации по цветам особенно актуальна в средах передачи данных, в которых отсутствует обработка входящего потока информации на принимающей стороне.
